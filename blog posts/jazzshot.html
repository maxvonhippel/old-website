<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<title>jazzshot</title>
	<! --- styles --->
	<style>
		#tutorial {
	    	margin-top: 10px;
			margin-bottom: 10px;
			margin-right: 100px;
			margin-left: 100px;
		}
		
		ol {
	    		width: 70%;
	    		margin: auto;
		}
		
		path {
		  	stroke: #fff;
		  	fill-rule: evenodd;
		}
		
		text {
		  	font-family: Arial, sans-serif;
		  	font-size: 12px;
		}
		
		* {
		    	padding: 0;
		    	margin: 0;
		}
		  
		.fit { /* set relative picture size */
		    	max-width: 100%;
		    	max-height: 100%;
		}
		  
		.center {
		    	display: block;
		    	margin: auto;
		}

	</style>
</head>
<body>

<center><font face="Hiragino sans" color=#464646 size="3"><a href="http://mxvh.pl">(HOME)</a></font></center>

<center><font face="Hiragino sans" color=#464646 size="7">Jazz Shot, Part I: Design Stage.</font></center>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
	Jazz Shot is a computer algorithm which synthesizes synesthesia in order to translate photographs into jazz music. There are two types of jazz music: <a href="https://www.youtube.com/watch?v=GNCd_ERZvZM">Good Jazz</a>, and <a href="https://youtu.be/EstPgi4eMe4">Avant-Garde Jazz</a>. One might interpret this jazz as being more on the Avant-Garde side of things. Experimental, perhaps. A bit like Cecil Taylor in slow motion, with literally perfect time.
	<br><br>
	<center><b>Tools in the App</b></center>
	<br>
In order to build Jazz Shot, I needed to get the R,G,B values of a bunch of colors. I need these values in order to create the initial values of my empty clusters for k-means clustering. To do that, I looked at color wheels online, and then found the correct R,G,B values <a href="http://www.tayloredmktg.com/rgb/#GRE">here</a>. Next, I needed to turn those colors into useful code. To do that, I found this <a href="http://uicolor.xyz/#/hex-to-ui">awesome color-format- translation website</a>.
	<br><br>
	<center><b>Design of the App</b></center>
	<br>
	<center>obj-c front-end iOS app -->> c algorithm for image analytics</center>
	<br>
	The obj-c front-end runs a user interface allowing the user to either capture or select a photo. The photo is parsed in obj-c and a file is output wherein the first line is: width height (in pixels), and every line after that is just r g b r g b r g b etc etc etc. That text file is read into the c script (jazzshot.c) and then processed.
	<br><br>
	<center><b>jazzshot.c</b></center>
	<br>
	I have two important structs:
	<br>	
</font></div>
	
	<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #888888">// this is a pixel</span>
typdef <span style="color: #008800; font-weight: bold">struct</span> pixel {
   <span style="color: #333399; font-weight: bold">int</span> red;
<span style="color: #333399; font-weight: bold">int</span> green;
   <span style="color: #333399; font-weight: bold">int</span> blue;
} <span style="color: #333399; font-weight: bold">pixel_t</span>;
<span style="color: #888888">// this is an image</span>
typdef <span style="color: #008800; font-weight: bold">struct</span> image {
   <span style="color: #333399; font-weight: bold">int</span> height;
<span style="color: #333399; font-weight: bold">int</span> width;
   <span style="color: #333399; font-weight: bold">pixel_t</span> pixels[width][height];
} <span style="color: #333399; font-weight: bold">image_t</span>;
</pre></div>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
	This is where we get to the cool stuff.
	<br><br>
	<center><b>PHILOSOPHY OF THE APP</b></center>
	<br>
	Jazz Shot turns an image into a musical composition. To do this, the composition of the image translates to the composition of the music. The colors of the image translate to the notes of the music.
	<br><br>
	<center><b>How to Translate Color Into Sound</b></center>
	<br>
	There are an infinity of possible translations of color into sound. Maybe a b# sounds like dark purple to you, but it sounds like olive green to me. I goofed around on Wikipedia for a while, and then after some googling (what academics call research), I stumbled upon <a href="http://www.flutopedia.com/sound_color.htm">this amazing website</a>. But having my app upload and download from that site would be far too much work. So I went down the rabbit hole of weird piano blogs, and found <a href="http://wagneric.com/audiocolors.html">this much simpler tool</a>:
<br>
<br>
<table bgcolor=#CCCCCC align=center>
<tr>
<td align=right>
<font face=courier>
<font color=#FF0000>
 F     --  349.228231 Hz ~ 383.980501 THz ~ 780.749171 nm <br>
 F#    --  369.994423 Hz ~ 406.813170 THz ~ 736.929087 nm <br>
 G     --  391.995436 Hz ~ 431.003540 THz ~ 695.568436 nm <br>
 G#    --  415.304698 Hz ~ 456.632344 THz ~ 656.529179 nm <br>
</font><font color=#FF7030>
 A     --  440.000000 Hz ~ 483.785116 THz ~ 619.681028 nm <br>
</font><font color=#FFFF00>
 Bflat --  466.163762 Hz ~ 512.552476 THz ~ 584.901004 nm <br>
</font><font color=#008000>
 B     --  493.883301 Hz ~ 543.030432 THz ~ 552.073033 nm <br>
 C     --  523.251131 Hz ~ 575.320702 THz ~ 521.087555 nm <br>
</font><font color=#0040FF>
 C#    --  554.365262 Hz ~ 609.531052 THz ~ 491.841158 nm <br>
</font><font color=#0000FF>
 D     --  587.329536 Hz ~ 645.775654 THz ~ 464.236235 nm <br>
</font><font color=#800080>
 Eflat --  622.253967 Hz ~ 684.175473 THz ~ 438.180657 nm <br>
 E     --  659.255114 Hz ~ 724.858663 THz ~ 413.587466 nm <br>
 F     --  698.456463 Hz ~ 767.961002 THz ~ 390.374586 nm <br>
</font>
</font>
</td>
</tr>
</table>
<br>
Using that mapping, I can now basically shift colors to their closest approximations on that chart and then generate the appropriate piano key notes (it is important to note (bad pun intended) that as piano notes are discrete, whereas colors are continuous, I must essentially “cast” the colors to their closest “integer” approximations, so to speak). But note that the above chart is in nm - and I’m using R,G,B. So the final translation comes out as:
</font></div>

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-yw4l{vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-yw4l">RGB</th>
    <th class="tg-yw4l">nm</th>
    <th class="tg-yw4l">Color Name</th>
    <th class="tg-yw4l">Note</th>
  </tr>
  <tr>
    <td class="tg-yw4l">(97,0,0)</td>
    <td class="tg-yw4l">780</td>
    <td class="tg-yw4l">RED</td>
    <td class="tg-yw4l">F</td>
  </tr>
  <tr>
    <td class="tg-yw4l">(186,0,0)</td>
    <td class="tg-yw4l">737</td>
    <td class="tg-yw4l">LIGHT RED</td>
    <td class="tg-yw4l">F#</td>
  </tr>
  <tr>
    <td class="tg-yw4l">(255,0,0)</td>
    <td class="tg-yw4l">695</td>
    <td class="tg-yw4l">FIRE TRUCK RED</td>
    <td class="tg-yw4l">G</td>
  </tr>
  <tr>
    <td class="tg-yw4l">(255,0,0)</td>
    <td class="tg-yw4l">695</td>
    <td class="tg-yw4l">FIRE TRUCK RED</td>
    <td class="tg-yw4l">G#</td>
  </tr>
  <tr>
    <td class="tg-yw4l">(255,119,0)</td>
    <td class="tg-yw4l">620</td>
    <td class="tg-yw4l">LIGHT ORANGE</td>
    <td class="tg-yw4l">A</td>
  </tr>
  <tr>
    <td class="tg-yw4l">(255,239,0)</td>
    <td class="tg-yw4l">585</td>
    <td class="tg-yw4l">YELLOW</td>
    <td class="tg-yw4l">B flat</td>
  </tr>
  <tr>
    <td class="tg-yw4l">(169,255,0)</td>
    <td class="tg-yw4l">552</td>
    <td class="tg-yw4l">LIME GREEN</td>
    <td class="tg-yw4l">B</td>
  </tr>
  <tr>
    <td class="tg-yw4l">(58,255,0)</td>
    <td class="tg-yw4l">521</td>
    <td class="tg-yw4l">CRAYON GREEN</td>
    <td class="tg-yw4l">C</td>
  </tr>
  <tr>
    <td class="tg-yw4l">(0,255,234)</td>
    <td class="tg-yw4l">492</td>
    <td class="tg-yw4l">CYAN</td>
    <td class="tg-yw4l">C#</td>
  </tr>
  <tr>
    <td class="tg-yw4l">(0,142,255)</td>
    <td class="tg-yw4l">464</td>
    <td class="tg-yw4l">CRAYON BLUE</td>
    <td class="tg-yw4l">D</td>
  </tr>
  <tr>
    <td class="tg-yw4l">(17,0,255)</td>
    <td class="tg-yw4l">438</td>
    <td class="tg-yw4l">OCEAN BLUE</td>
    <td class="tg-yw4l">E flat</td>
  </tr>
  <tr>
    <td class="tg-yw4l">(120,0,233)</td>
    <td class="tg-yw4l">414</td>
    <td class="tg-yw4l">PURPLE</td>
    <td class="tg-yw4l">E</td>
  </tr>
  <tr>
    <td class="tg-yw4l">(121,0,141)</td>
    <td class="tg-yw4l">390</td>
    <td class="tg-yw4l">ROYAL PURPLE</td>
    <td class="tg-yw4l">F</td>
  </tr>
</table>
</center>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
(Made with <a href="http://www.tablesgenerator.com">this table making tool</a> and <a href="http://lsrtools.1apps.com/wavetorgb/">this awesome wavelength to color translator</a>)
<br><br>
<center><b>How to Translate Image Composition Into Musical Composition</b></center>
<br>
The compositional elements of a photograph are debatable. For the purposes of Jazz Shot, I start by finding centroids of common colors using a <a href="https://en.wikipedia.org/wiki/K-means_clustering">k-means algorithm</a> in order to select which notes to play. But that begs the question: when should I play those notes? I use the X,Y location of the centroids of these common-color clusters to determine the location where the note begins, and I use the size (approximate width) of the color-cluster to determine how long the note should last for. But playing just one note would be boring, so instead I play a scale, starting with the note we selected based off of color. This means I need a way to select which scale pattern to use, and which rhythm to play this scale in.
<br>
<br>
<center><i>Scales</i></center>
<br>
Based off of a meta-survey of various non-academic sites online with dubious English-language skills and more than zero instances of classic clip- art, I get the impression that Jazz pianists tend to rely on the modal scales. Wikipedia, the world’s foremost bonafide source of 100% concrete truth, appears to back this up. According to that unquestionable bedrock of intelligencia, the most important modal jazz scales are the following:
<br>
<br>
</font></div>

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-yw4l{vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-yw4l">I</th>
    <th class="tg-yw4l">Ionian mode</th>
    <th class="tg-yw4l">C D E F G A B C</th>
  </tr>
  <tr>
    <td class="tg-yw4l">II</td>
    <td class="tg-yw4l">Dorian mode</td>
    <td class="tg-yw4l">C D E♭F G A B♭ C</td>
  </tr>
  <tr>
    <td class="tg-yw4l">III</td>
    <td class="tg-yw4l">Phrygian mode</td>
    <td class="tg-yw4l">C D♭ E♭ F G A♭ B♭ C</td>
  </tr>
  <tr>
    <td class="tg-yw4l">IV</td>
    <td class="tg-yw4l">Lydian mode</td>
    <td class="tg-yw4l">C D E F# G A B C</td>
  </tr>
  <tr>
    <td class="tg-yw4l">V</td>
    <td class="tg-yw4l">Mixolydian mode</td>
    <td class="tg-yw4l">C D E F G A B♭C</td>
  </tr>
  <tr>
    <td class="tg-yw4l">VI</td>
    <td class="tg-yw4l">Aeolian mode</td>
    <td class="tg-yw4l">C D E♭F G A♭B♭C</td>
  </tr>
  <tr>
    <td class="tg-yw4l">VIIø</td>
    <td class="tg-yw4l">Locrian mode</td>
    <td class="tg-yw4l">C D♭E♭F G♭A♭B♭C</td>
  </tr>
</table>
</center>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
<footer><a href="https://en.wikipedia.org/wiki/Jazz_scale#Modes_of_the_major_scale">(SOURCE)</a></footer>
<br>
<br>
I intuitively feel that the more flat/sharp the notes on a scale are, the more entropic the scale will feel. If I assign 1 point to every sharp note, and 2 points to every flat note, and map in descending order of points, I get the following:
<br>
<br>
<lu>
<li>Locrian mode: 10 points</li>
<li>Phrygian mode: 8 points</li>
<li>Aeolian mode: 6 points</li>
<li>Doriam mode: 4 points</li>
<li>Mixolydian mode: 2 points</li>
<li>Lydrian mode: 1 point</li>
<li>Ionian mode: 0 points</li>
</lu>
<br>
Now I need to translate visual entropy into audible entropy. For each centroid, I will find the “distance” between each pixel in the centroid and the average color, and then I will find the average “distance.” I will calculate distance using the standard color distance formula:
</font></div>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">Point1 has R1 G1 B1
Point2 has R2 G2 B2
<span style="color: #888888">// Distance between colors is</span>
d<span style="color: #333333">=</span>sqrt( (r2<span style="color: #333333">-</span>r1)<span style="color: #333333">^</span><span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">+</span> (g2<span style="color: #333333">-</span>g1)<span style="color: #333333">^</span><span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">+</span> (b2<span style="color: #333333">-</span>b1)<span style="color: #333333">^</span><span style="color: #0000DD; font-weight: bold">2</span> )
<span style="color: #888888">// Percentage is</span>
p<span style="color: #333333">=</span>d<span style="color: #333333">/</span>sqrt( (<span style="color: #0000DD; font-weight: bold">255</span>)<span style="color: #333333">^</span><span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">+</span> (<span style="color: #0000DD; font-weight: bold">255</span>)<span style="color: #333333">^</span><span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">+</span> (<span style="color: #0000DD; font-weight: bold">255</span>)<span style="color: #333333">^</span><span style="color: #0000DD; font-weight: bold">2</span> )
</pre></div>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
<footer><a href="http://stackoverflow.com/a/9018153/1586231">(SOURCE)</a></footer>
<br>
<br>
I will then equate this average color “distance” to a metric of “entropy” (note that I am using some mathematical vocabulary quite loosely in this post. I am fully aware that distance, entropy, integer, cast, etc. really do not mean what I use them to articulate in this post. But a more technical vocabulary would be a) harder to write with and b) harder for people interested in this from a jazz rather than computer science background to understand).
<br>
<br>
<lu>
<li>0-5% “entropy” -> 0 “points” -> Ionian mode</li>
<li>6-10% “entropy” -> 1 “point” -> Lydian mode</li>
<li>11-15% “entropy” -> 2 “points” -> Mixolydian mode</li>
<li>16-20% “entropy” -> 4 “points” -> Doriam mode</li>
<li>21-25% “entropy” -> 6 “points” -> Aeolian mode</li>
<li>26-30% “entropy” -> 8 “points” -> Phrygian mode</li>
<li>31+% “entropy” -> 10 “points” -> Locrian mode (unlikely to occur)</li>
</lu>
<br>
(Computer Science folks should note that I deliberately using only a single iteration of k-means clustering, so when I say “k-means clustering” I’m honestly using the term very loosely. I designed it this way in order to ensure a decent number of separate notes.)
<br>
<br>
<center><i>Rhythm/Pattern</i></center>
<br>
I am not going to do anything too fancy with the rhythm/pattern. In fact, I am going to do almost nothing with it, because I think the more complexity I put into this thing, the less likely it is to ever produce anything even remotely listenable. So here is my rhythm algorithm:
</font></div>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #888888">// width of the centroid in %</span>
W <span style="color: #333333">=</span> ( Width of Color Centroid ) <span style="color: #333333">/</span> ( Width of Image )
<span style="color: #888888">// height of the centroid in %</span>
H <span style="color: #333333">=</span> ( Height of Color Centroid ) <span style="color: #333333">/</span> ( Height of Image )
<span style="color: #888888">// very rough estimation of average diameter of centroid in %</span>
AV <span style="color: #333333">=</span> ( W <span style="color: #333333">+</span> H ) <span style="color: #333333">/</span> <span style="color: #0000DD; font-weight: bold">2</span>
<span style="color: #888888">// length of pattern of notes, in quarter-notes, within a 16-bar</span>
sequence
L <span style="color: #333333">=</span> AV <span style="color: #333333">*</span> <span style="color: #0000DD; font-weight: bold">4</span> <span style="color: #333333">*</span> <span style="color: #0000DD; font-weight: bold">16</span>
<span style="color: #888888">// distance from center of centroid to center of image</span>
R <span style="color: #333333">=</span> distance from center of centroid to center of image
RP <span style="color: #333333">=</span> R <span style="color: #333333">/</span> (Whichever is largest, width or height of image)
<span style="color: #888888">// where in the 16-bar sequence the pattern begins</span>
S <span style="color: #333333">=</span> RP <span style="color: #333333">*</span> <span style="color: #0000DD; font-weight: bold">4</span> <span style="color: #333333">*</span> <span style="color: #0000DD; font-weight: bold">16</span>
</pre></div>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
<br>
<br>
<center><b>What’s Next?</b></center>
<br>
Over the coming 2 weeks I will be coding the c and obj-c components of Jazz Shot. As I progress, I will update this blog with open source code, explanations of my algorithms, and more music-oriented posts such as this
one (featuring a lot of cool pictures and pseudocode and jokes about Wikipedia).
<br>
<br>
<center><b>What is this?</b></center>
<br>
This is my final project for History of Jazz Since 1965 (SP16) at Dartmouth College, taught by Professor <a href="http://music.dartmouth.edu/people/donald-glasgo">Don Glasgo</a>, who didn’t hear me say I don’t like Cecil Taylor and who should please give me an A on this assignment.
</font></div>

<center><font face="Hiragino sans" color=#464646 size="7">Jazz Shot, Part II: Fixes & Image Data</font></center>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
In response to my last post, I received the following feedback from my friend Clara Chin, who actually plays piano (as opposed to Who Actually Read the Wikipedia Entree On Pianos, as I might be generously described):<br><br><i>"...you can technically start a mode on any note, so locrian and dorian can have the same number of flats..."</i><br><br>I thus propose the following solution for determining modal scale based on a color centroid:
<br>
<br>
<lu>
<li>Find the percent “entropy” of the color of the centroid</li>
<li>Calculate each of the modal scales starting with the note produced by the average color of the centroid</li>
<li>Sort the produced modal scales by “entropy” (as described in the last post)</li>
<li>Elect a mode based on relative “entropy” of the color centroid (as described in the last post)</li>
</lu>
<br>
<br>
In other words, the same process as before, but dynamic rather than static, due to the permeative nature of modal scales.
<br>
<br>
<center><b>Image Data</b></center>
<br>
<br>
Here are some things I learned while writing image processing software today:
<br>
<br>
<lu>
<li>an iPhone actually does not have tens of gigabytes of RAM</li>
<li>k-means is very hard to do fast without ridiculous RAM, and so using a real k- means algorithm would mean either making the user wait a very long time, or only allowing images so small a snail might hang them up as art</li>
<li>iOS image classes and the conversions between them can be very confusing</li>
</lu>
<br>
<br>
With all that in mind, I wrote the following algorithm to produce useful data on centroids in a photograph. NSObjects used instead of structs are simple (it’s clear what I put in them just by looking at the code), and I they will be in the open source project once I post it, so I won’t clutter up this explanation with them right now.
<br><br>
1) Let’s set up our simple data structures to hold pixels for analysis.
</font></div>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #888888">// I begin with the primary &amp; secondary colors</span>
NSMutableArray <span style="color: #333333">*</span>yellowLocs <span style="color: #333333">=</span> [[NSMutableArray alloc] init];
NSMutableArray <span style="color: #333333">*</span>greenLocs <span style="color: #333333">=</span> [[NSMutableArray alloc] init];
NSMutableArray <span style="color: #333333">*</span>blueLocs <span style="color: #333333">=</span> [[NSMutableArray alloc] init];
NSMutableArray <span style="color: #333333">*</span>violetLocs <span style="color: #333333">=</span> [[NSMutableArray alloc] init];
NSMutableArray <span style="color: #333333">*</span>orangeLocs <span style="color: #333333">=</span> [[NSMutableArray alloc] init];
NSMutableArray <span style="color: #333333">*</span>redLocs <span style="color: #333333">=</span> [[NSMutableArray alloc] init];
<span style="color: #888888">// this is a blank placeholder point to start off each array</span>
CGPoint blank_point <span style="color: #333333">=</span> CGPointMake(<span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #0000DD; font-weight: bold">0</span>);
<span style="color: #888888">// we must add a header object, like a sentinel, to each array</span>
ColorPoint <span style="color: #333333">*</span>yellowHeader <span style="color: #333333">=</span> [[ColorPoint alloc] init];
yellowHeader.color <span style="color: #333333">=</span> [UIColor yellowColor];
yellowHeader.point <span style="color: #333333">=</span> <span style="color: #333333">&amp;</span>(blank_point);
[yellowLocs addObject<span style="color: #333333">:</span>yellowHeader];
ColorPoint <span style="color: #333333">*</span>greenHeader <span style="color: #333333">=</span> [[ColorPoint alloc] init];
greenHeader.color <span style="color: #333333">=</span> [UIColor greenColor];
greenHeader.point <span style="color: #333333">=</span> <span style="color: #333333">&amp;</span>(blank_point);
[greenLocs addObject<span style="color: #333333">:</span>greenHeader];
ColorPoint <span style="color: #333333">*</span>blueHeader <span style="color: #333333">=</span> [[ColorPoint alloc] init];
blueHeader.color <span style="color: #333333">=</span> [UIColor blueColor];
blueHeader.point <span style="color: #333333">=</span> <span style="color: #333333">&amp;</span>(blank_point);
[blueLocs addObject<span style="color: #333333">:</span>blueHeader];
ColorPoint <span style="color: #333333">*</span>violetHeader <span style="color: #333333">=</span> [[ColorPoint alloc] init];
violetHeader.color <span style="color: #333333">=</span> [UIColor colorWithRed<span style="color: #333333">:</span><span style="color: #6600EE; font-weight: bold">0.58</span> green<span style="color: #333333">:</span><span style="color: #6600EE; font-weight: bold">0.00</span>
<span style="color: #997700; font-weight: bold">blue:</span><span style="color: #6600EE; font-weight: bold">0.83</span> alpha<span style="color: #333333">:</span><span style="color: #6600EE; font-weight: bold">1.0</span>];
violetHeader.point <span style="color: #333333">=</span> <span style="color: #333333">&amp;</span>(blank_point);
[violetLocs addObject<span style="color: #333333">:</span>violetHeader];
ColorPoint <span style="color: #333333">*</span>orangeHeader <span style="color: #333333">=</span> [[ColorPoint alloc] init];
orangeHeader.color <span style="color: #333333">=</span> [UIColor orangeColor];
orangeHeader.point <span style="color: #333333">=</span> <span style="color: #333333">&amp;</span>(blank_point);
[orangeLocs addObject<span style="color: #333333">:</span>orangeHeader];
ColorPoint <span style="color: #333333">*</span>redHeader <span style="color: #333333">=</span> [[ColorPoint alloc] init];
redHeader.color <span style="color: #333333">=</span> [UIColor redColor];
redHeader.point <span style="color: #333333">=</span> <span style="color: #333333">&amp;</span>(blank_point);
[redLocs addObject<span style="color: #333333">:</span>redHeader];
<span style="color: #888888">// this holds all the arrays</span>
NSMutableArray <span style="color: #333333">*</span>arrayOfColorArrays <span style="color: #333333">=</span> [[NSMutableArray alloc]
init];
[arrayOfColorArrays addObject<span style="color: #333333">:</span>yellowLocs];
[arrayOfColorArrays addObject<span style="color: #333333">:</span>greenLocs];
[arrayOfColorArrays addObject<span style="color: #333333">:</span>violetLocs];
[arrayOfColorArrays addObject<span style="color: #333333">:</span>orangeLocs];
[arrayOfColorArrays addObject<span style="color: #333333">:</span>blueLocs];
[arrayOfColorArrays addObject<span style="color: #333333">:</span>redLocs];
</pre></div>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
2) Now we need to iterate over pixels and put them into data structures for analysis.
</font></div>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #888888">// Iterate over all of the pixels</span>
UInt32 <span style="color: #333333">*</span> currentPixel <span style="color: #333333">=</span> pixels;
<span style="color: #888888">// for each row of pixels</span>
<span style="color: #333399; font-weight: bold">int</span> iCount <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>, jCount <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
<span style="color: #008800; font-weight: bold">for</span> (NSUInteger j <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; j <span style="color: #333333">&lt;</span> height; j<span style="color: #333333">++</span>) {
    <span style="color: #888888">// for each pixel in the row</span>
    iCount <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
    <span style="color: #008800; font-weight: bold">if</span> (<span style="color: #333333">++</span>jCount <span style="color: #333333">&gt;=</span> <span style="color: #0000DD; font-weight: bold">10</span>) {
        <span style="color: #008800; font-weight: bold">for</span> (NSUInteger i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> width; i<span style="color: #333333">++</span>) {
            <span style="color: #008800; font-weight: bold">if</span> (<span style="color: #333333">++</span>iCount <span style="color: #333333">&gt;=</span> <span style="color: #0000DD; font-weight: bold">10</span>) {
                UInt32 color <span style="color: #333333">=</span> <span style="color: #333333">*</span>currentPixel;
                UIColor <span style="color: #333333">*</span>cur_ui_color <span style="color: #333333">=</span> [[UIColor alloc] init];
                                cur_ui_color <span style="color: #333333">=</span> [UIColor
<span style="color: #997700; font-weight: bold">colorWithRed:</span>(CGFloat)(R(color)<span style="color: #333333">/</span><span style="color: #6600EE; font-weight: bold">255.0</span>) green<span style="color: #333333">:</span>(CGFloat)
(G(color)<span style="color: #333333">/</span><span style="color: #6600EE; font-weight: bold">255.0</span>) blue<span style="color: #333333">:</span>(CGFloat)(B(color)<span style="color: #333333">/</span><span style="color: #6600EE; font-weight: bold">255.0</span>) alpha<span style="color: #333333">:</span><span style="color: #0000DD; font-weight: bold">1</span>];
                                NSMutableArray<span style="color: #333333">*</span> distanceArray <span style="color: #333333">=</span>
[[NSMutableArray alloc] init];
                <span style="color: #008800; font-weight: bold">for</span> (NSMutableArray<span style="color: #333333">*</span> cur_array <span style="color: #008800; font-weight: bold">in</span>
arrayOfColorArrays) {
<span style="color: #997700; font-weight: bold">objectAtIndex:</span><span style="color: #0000DD; font-weight: bold">0</span>];
ColorPoint<span style="color: #333333">*</span> curpoint <span style="color: #333333">=</span> [cur_array
UIColor<span style="color: #333333">*</span> comparecolor <span style="color: #333333">=</span> curpoint.color;
<span style="color: #333399; font-weight: bold">size_t</span> numComponents <span style="color: #333333">=</span>
CGColorGetNumberOfComponents(comparecolor.CGColor);
                        <span style="color: #008800; font-weight: bold">if</span> (numComponents <span style="color: #333333">&gt;=</span> <span style="color: #0000DD; font-weight: bold">3</span>) {
                                                       CGFloat dif
<span style="color: #333333">=</span> sqrt( pow(((CGColorGetComponents(comparecolor.CGColor))[<span style="color: #0000DD; font-weight: bold">0</span>]<span style="color: #333333">*</span><span style="color: #0000DD; font-weight: bold">255</span>)
<span style="color: #333333">-</span> R(color), <span style="color: #0000DD; font-weight: bold">2</span>) <span style="color: #333333">+</span> pow(((CGColorGetComponents(comparecolor.CGColor))
[<span style="color: #0000DD; font-weight: bold">1</span>]<span style="color: #333333">*</span><span style="color: #0000DD; font-weight: bold">255</span>) <span style="color: #333333">-</span> G(color), <span style="color: #0000DD; font-weight: bold">2</span>) <span style="color: #333333">+</span>
pow(((CGColorGetComponents(comparecolor.CGColor))[<span style="color: #0000DD; font-weight: bold">2</span>]<span style="color: #333333">*</span><span style="color: #0000DD; font-weight: bold">255</span>) <span style="color: #333333">-</span>
B(color), <span style="color: #0000DD; font-weight: bold">2</span>));
                            CGFloat percentage_dif <span style="color: #333333">=</span> dif <span style="color: #333333">/</span>
sqrt(<span style="color: #0000DD; font-weight: bold">3</span><span style="color: #333333">*</span>pow(<span style="color: #0000DD; font-weight: bold">255</span>, <span style="color: #0000DD; font-weight: bold">2</span>));
[distanceArray addObject<span style="color: #333333">:</span>[NSNumber
<span style="color: #997700; font-weight: bold">numberWithFloat:</span>percentage_dif]];
                                               } <span style="color: #008800; font-weight: bold">else</span> {
printf(<span style="background-color: #fff0f0">&quot;ERROR: num_components is %zu and it should be 3 or 4 (w/</span>
alpha) so that doesn<span style="color: #FF0000; background-color: #FFAAAA">&#39;</span>t make sense.<span style="color: #FF0000; background-color: #FFAAAA">\</span>n<span style="background-color: #fff0f0">&quot;, numComponents);</span>
                                              }
alloc] init];
                                       <span style="color: #008800; font-weight: bold">return</span>;
   ColorPoint <span style="color: #333333">*</span>cur_color_point <span style="color: #333333">=</span> [[ColorPoint
   cur_color_point.color <span style="color: #333333">=</span> cur_ui_color;
CGPoint cur_point <span style="color: #333333">=</span> CGPointMake(i, j);
   cur_color_point.point <span style="color: #333333">=</span> <span style="color: #333333">&amp;</span>(cur_point);
   <span style="color: #008800; font-weight: bold">if</span> (cur_color_point) {
}
                                               NSNumber <span style="color: #333333">*</span>min<span style="color: #333333">=</span>
[distanceArray valueForKeyPath<span style="color: #333333">:</span><span style="background-color: #fff0f0">@&quot;@min.doubleValue&quot;</span>];
                                                NSMutableArray<span style="color: #333333">*</span>
bestArray <span style="color: #333333">=</span> [arrayOfColorArrays objectAtIndex<span style="color: #333333">:</span>[distanceArray
<span style="color: #997700; font-weight: bold">indexOfObject:</span>min]];
<span style="color: #997700; font-weight: bold">addObject:</span>cur_color_point];
[bestArray
                                 } <span style="color: #008800; font-weight: bold">else</span> {
color point does not exist <span style="color: #008800; font-weight: bold">for</span> some reason, which makes no
sense.<span style="color: #FF0000; background-color: #FFAAAA">\</span>n<span style="background-color: #fff0f0">&quot;);</span>
} }
jCount <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; }
        currentPixel<span style="color: #333333">++</span>;
    }
printf(<span style="background-color: #fff0f0">&quot;Error:</span>
<span style="color: #008800; font-weight: bold">return</span>;
iCount <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
}
</pre></div>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
3) Finally, we run analysis on the clusters and print the results.
</font></div>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">NSMutableArray<span style="color: #333333">*</span> centroid_list<span style="color: #333333">=</span> [[NSMutableArray alloc] init];
<span style="color: #888888">// iterate over each array in the array of color arrays</span>
<span style="color: #008800; font-weight: bold">for</span> (NSMutableArray<span style="color: #333333">*</span> cur_array <span style="color: #008800; font-weight: bold">in</span> arrayOfColorArrays) {
    <span style="color: #333399; font-weight: bold">uint64_t</span> num_colors <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
    CGFloat r <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>, g <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>, b <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>, x<span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>, y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
    <span style="color: #008800; font-weight: bold">for</span> (ColorPoint<span style="color: #333333">*</span> cur_point <span style="color: #008800; font-weight: bold">in</span> cur_array) {
           UIColor<span style="color: #333333">*</span> compare_color <span style="color: #333333">=</span> cur_point.color;
               CGColorRef cur_compare_color <span style="color: #333333">=</span> [compare_color
CGColor];
           <span style="color: #333399; font-weight: bold">size_t</span> numComponents <span style="color: #333333">=</span>
CGColorGetNumberOfComponents(cur_compare_color);
        <span style="color: #008800; font-weight: bold">if</span> (numComponents <span style="color: #333333">&gt;=</span> <span style="color: #0000DD; font-weight: bold">3</span>) {
            <span style="color: #008800; font-weight: bold">if</span> (cur_point.point <span style="color: #333333">!=</span> <span style="color: #007020">NULL</span>) {
                CGPoint cur_point_get <span style="color: #333333">=</span> <span style="color: #333333">*</span>(cur_point.point);
                <span style="color: #008800; font-weight: bold">if</span> (cur_point_get.x <span style="color: #333333">+</span> cur_point_get.y <span style="color: #333333">&gt;</span> <span style="color: #0000DD; font-weight: bold">0</span>) {
                <span style="color: #888888">// add its properties to our going average to be</span>
divided out
                                               r <span style="color: #333333">+=</span>
((CGColorGetComponents(compare_color.CGColor))[<span style="color: #0000DD; font-weight: bold">0</span>]<span style="color: #333333">*</span><span style="color: #0000DD; font-weight: bold">255</span>);
                        g <span style="color: #333333">+=</span>
((CGColorGetComponents(compare_color.CGColor))[<span style="color: #0000DD; font-weight: bold">1</span>]<span style="color: #333333">*</span><span style="color: #0000DD; font-weight: bold">255</span>);
                        b <span style="color: #333333">+=</span>
((CGColorGetComponents(compare_color.CGColor))[<span style="color: #0000DD; font-weight: bold">2</span>]<span style="color: #333333">*</span><span style="color: #0000DD; font-weight: bold">255</span>);
} }
}
x <span style="color: #333333">+=</span> cur_point_get.x;
y <span style="color: #333333">+=</span> cur_point_get.y;
<span style="color: #333333">++</span>num_colors;
    }
    <span style="color: #008800; font-weight: bold">if</span> (num_colors <span style="color: #333333">&gt;</span> <span style="color: #0000DD; font-weight: bold">0</span>) {
        r <span style="color: #333333">/=</span> num_colors;
        g <span style="color: #333333">/=</span> num_colors;
        b <span style="color: #333333">/=</span> num_colors;
        x <span style="color: #333333">/=</span> num_colors;
        y <span style="color: #333333">/=</span> num_colors;
            <span style="color: #888888">// find average entropy</span>
        CGFloat entropy <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>, items <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>, width <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
        <span style="color: #008800; font-weight: bold">for</span> (ColorPoint<span style="color: #333333">*</span> cur_point <span style="color: #008800; font-weight: bold">in</span> cur_array) {
            UIColor<span style="color: #333333">*</span> compare_color <span style="color: #333333">=</span> cur_point.color;
            CGColorRef cur_compare_color <span style="color: #333333">=</span> [compare_color
CGColor];
            <span style="color: #333399; font-weight: bold">size_t</span> numComponents <span style="color: #333333">=</span>
CGColorGetNumberOfComponents(cur_compare_color);
            <span style="color: #008800; font-weight: bold">if</span> (numComponents <span style="color: #333333">&gt;=</span> <span style="color: #0000DD; font-weight: bold">3</span> <span style="color: #333333">&amp;&amp;</span> cur_point.point <span style="color: #333333">!=</span> <span style="color: #007020">NULL</span>) {
                                CGFloat cur_dif <span style="color: #333333">=</span> sqrt(
pow((((CGColorGetComponents(compare_color.CGColor))[<span style="color: #0000DD; font-weight: bold">0</span>]<span style="color: #333333">*</span><span style="color: #0000DD; font-weight: bold">255</span>) <span style="color: #333333">-</span> r),
<span style="color: #0000DD; font-weight: bold">2</span>) <span style="color: #333333">+</span> pow((((CGColorGetComponents(compare_color.CGColor))[<span style="color: #0000DD; font-weight: bold">1</span>]<span style="color: #333333">*</span><span style="color: #0000DD; font-weight: bold">255</span>) <span style="color: #333333">-</span>
  g), <span style="color: #0000DD; font-weight: bold">2</span>) <span style="color: #333333">+</span> pow((((CGColorGetComponents(compare_color.CGColor))
[<span style="color: #0000DD; font-weight: bold">2</span>]<span style="color: #333333">*</span><span style="color: #0000DD; font-weight: bold">255</span>) <span style="color: #333333">-</span> b), <span style="color: #0000DD; font-weight: bold">2</span>));
                                CGFloat cur_perc_dif <span style="color: #333333">=</span> cur_dif <span style="color: #333333">/</span>
sqrt(<span style="color: #0000DD; font-weight: bold">3</span><span style="color: #333333">*</span>pow(<span style="color: #0000DD; font-weight: bold">255</span>, <span style="color: #0000DD; font-weight: bold">2</span>));
                entropy <span style="color: #333333">+=</span> cur_perc_dif;
} }
        <span style="color: #008800; font-weight: bold">if</span> (items <span style="color: #333333">&gt;</span> <span style="color: #0000DD; font-weight: bold">0</span>) {
leave it alone
<span style="color: #888888">// entropy is so small anyway we can just</span>
init];
width <span style="color: #333333">/=</span> items;
    <span style="color: #888888">// put this data into a centroid</span>
Centroid<span style="color: #333333">*</span> cur_centroid <span style="color: #333333">=</span> [[Centroid alloc] init];
ColorPoint<span style="color: #333333">*</span> cur_centroid_point <span style="color: #333333">=</span> [[ColorPoint alloc]
CGPoint cur_point <span style="color: #333333">=</span> CGPointMake(x, y);
cur_centroid_point.point <span style="color: #333333">=</span> <span style="color: #333333">&amp;</span>(cur_point);
UIColor <span style="color: #333333">*</span>cur_centroid_color <span style="color: #333333">=</span> [UIColor colorWithRed<span style="color: #333333">:</span>
CGPoint cur_cg_point <span style="color: #333333">=</span> <span style="color: #333333">*</span>(cur_point.point);
width <span style="color: #333333">+=</span> ( cur_cg_point.x <span style="color: #333333">-</span> x );
<span style="color: #333333">++</span>items;
(CGFloat)(r<span style="color: #333333">/</span><span style="color: #0000DD; font-weight: bold">255</span>) green<span style="color: #333333">:</span>(CGFloat)(g<span style="color: #333333">/</span><span style="color: #0000DD; font-weight: bold">255</span>) blue<span style="color: #333333">:</span>(CGFloat)(b<span style="color: #333333">/</span><span style="color: #0000DD; font-weight: bold">255</span>)
<span style="color: #997700; font-weight: bold">alpha:</span><span style="color: #0000DD; font-weight: bold">1</span>];
} }
    cur_centroid_point.color <span style="color: #333333">=</span> cur_centroid_color;
    cur_centroid.color_point <span style="color: #333333">=</span> cur_centroid_point;
    cur_centroid.average_width <span style="color: #333333">=</span> fabs(width);
    cur_centroid.percent_entropy <span style="color: #333333">=</span> entropy;
        <span style="color: #888888">// now add entropy to our entropy list</span>
    [centroid_list addObject<span style="color: #333333">:</span>cur_centroid];
}
<span style="color: #888888">// test: did we get centroids????</span>
<span style="color: #008800; font-weight: bold">for</span> (Centroid<span style="color: #333333">*</span> cur_centroid <span style="color: #008800; font-weight: bold">in</span> centroid_list) {
        printf(<span style="background-color: #fff0f0">&quot;Found a centroid.</span><span style="color: #666666; font-weight: bold; background-color: #fff0f0">\n</span><span style="background-color: #fff0f0">&quot;</span>);
    ColorPoint <span style="color: #333333">*</span>cur_cp <span style="color: #333333">=</span> cur_centroid.color_point;
        CGPoint cur_cg_point <span style="color: #333333">=</span> <span style="color: #333333">*</span>(cur_cp.point);
        UIColor<span style="color: #333333">*</span> compare_color <span style="color: #333333">=</span> cur_cp.color;
        CGColorRef cur_compare_color <span style="color: #333333">=</span> [compare_color CGColor];
        <span style="color: #333399; font-weight: bold">size_t</span> numComponents <span style="color: #333333">=</span>
CGColorGetNumberOfComponents(cur_compare_color);
        <span style="color: #008800; font-weight: bold">if</span> (numComponents <span style="color: #333333">&gt;=</span> <span style="color: #0000DD; font-weight: bold">3</span> <span style="color: #333333">&amp;&amp;</span> cur_cp.point <span style="color: #333333">!=</span> <span style="color: #007020">NULL</span>) {
            <span style="color: #008800; font-weight: bold">const</span> CGFloat <span style="color: #333333">*</span>cur_components <span style="color: #333333">=</span>
CGColorGetComponents(cur_compare_color);
            NSLog(<span style="background-color: #fff0f0">@&quot;Centroid at (%f, %f) with width %f and entropy</span>
<span style="color: #333333">%</span>d and color R<span style="color: #333333">:%</span>f, G<span style="color: #333333">:%</span>f, B<span style="color: #333333">:%</span>f<span style="color: #FF0000; background-color: #FFAAAA">\</span>n<span style="background-color: #fff0f0">&quot;, cur_cg_point.x, cur_cg_point.y,</span>
cur_centroid.average_width, cur_centroid.percent_entropy,
(cur_components[<span style="color: #0000DD; font-weight: bold">0</span>] <span style="color: #333333">*</span> <span style="color: #0000DD; font-weight: bold">255</span>), (cur_components[<span style="color: #0000DD; font-weight: bold">1</span>] <span style="color: #333333">*</span> <span style="color: #0000DD; font-weight: bold">255</span>),
(cur_components[<span style="color: #0000DD; font-weight: bold">2</span>] <span style="color: #333333">*</span> <span style="color: #0000DD; font-weight: bold">255</span>));
}
}
</pre></div>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
Amazingly, this works! (Or at least appears to be working to me!) (Or at least produces numbers which sound sort of plausible!)  For an image of a waterfall, I get the results:
<br>
<br>
<lu>
<li>Looking at an array containing 4151 unique colors.</li>
<li>Looking at an array containing 1 unique colors.</li>
<li>Looking at an array containing 36521 unique colors.</li>
<li>Looking at an array containing 167 unique colors.</li>
<li>Looking at an array containing 1 unique colors.</li>
<li>Looking at an array containing 665 unique colors.</li>
<li>Found a centroid.</li>
<li>Centroid at (1659.000000, 2499.000000) with width 0.399663 and entropy 59 and color R:227.000000, G:230.400000, B:235.560000</li>
<li>Found a centroid.</li>
<li>Centroid at (1659.000000, 2499.000000) with width 0.045426 and
          
entropy 4396 and color R:169.209091, G:172.586364, B:178.136364</li>
<li>Found a centroid.</li>
<li>Centroid at (1659.000000, 2499.000000) with width 9.934132 and entropy 0 and color R:138.000000, G:128.000000, B:103.000000</li>
<li>Found a centroid.</li>
<li>Centroid at (1659.000000, 2499.000000) with width 2.494737 and entropy 23 and color R:51.750000, G:39.750000, B:12.500000</li>
</lu>
<br>
You may notice that I deviated from my original plan of using a c script. I realized it was easier to just process the data in obj-c, that it would have been to somehow pass a struct from one language to another. So I am ditching the whole “c backend” thing, and will be operating exclusively in obj-c for the rest of this project.
<br>
<br>
In my next post, I write and explain code to turn the numbers in the above example output into a jazz solo (for better or for worse!). I will also try to figure out how to properly format and syntax-highlight my code in Markdown. Ultimately, I will make my code available on GitHub, so the formatting of my Markdown shouldn’t be too consequential in the long run.
<br>
<br>
Credits today go to <a href="http://stackoverflow.com/a/30967091/1586231">this Stack Overflow answer</a>, Clara Chin, <a href="http://stackoverflow.com/questions/26341008/how-to-convert-uicolor-to-hex-and-display-in-nslog/30967091#30967091">this other Stack Overflow answer</a>, <a href="http://stackoverflow.com/questions/4155642/how-to-get-color-components-of-a-cgcolor-correctly/4155938#4155938">this Stack Overflow thread on color formats</a>, <a href="http://stackoverflow.com/questions/4155642/how-to-get-color-components-of-a-cgcolor-correctly/4155938#4155938">this answer regarding color numeric representations for iOS</a>, and <a href="http://www.colormatters.com/color-and-design/basic-color-theory">this random website on so-called “basic color theory”</a> (doesn’t seem too basic after all that code!).
<br>
<br>
</font></div>

<center><font face="Hiragino sans" color=#464646 size="7">Jazz Shot, Part III: Output & Music Creation</font></center>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
In my last post, I wrote image analytics code to create a list of color centroids with which to make music. This was the output I got from a sample picture of a waterfall:
<br>
<br>
</font></div>

<center>
  <style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-yw4l{vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-yw4l">I</th>
    <th class="tg-yw4l">Ionian mode</th>
    <th class="tg-yw4l">C D E F G A B C</th>
  </tr>
  <tr>
    <td class="tg-yw4l">II</td>
    <td class="tg-yw4l">Dorian mode</td>
    <td class="tg-yw4l">C D E♭F G A B♭ C</td>
  </tr>
  <tr>
    <td class="tg-yw4l">III</td>
    <td class="tg-yw4l">Phrygian mode</td>
    <td class="tg-yw4l">C D♭ E♭ F G A♭ B♭ C</td>
  </tr>
  <tr>
    <td class="tg-yw4l">IV</td>
    <td class="tg-yw4l">Lydian mode</td>
    <td class="tg-yw4l">C D E F# G A B C</td>
  </tr>
  <tr>
    <td class="tg-yw4l">V</td>
    <td class="tg-yw4l">Mixolydian mode</td>
    <td class="tg-yw4l">C D E F G A B♭C</td>
  </tr>
  <tr>
    <td class="tg-yw4l">VI</td>
    <td class="tg-yw4l">Aeolian mode</td>
    <td class="tg-yw4l">C D E♭F G A♭B♭C</td>
  </tr>
  <tr>
    <td class="tg-yw4l">VIIø</td>
    <td class="tg-yw4l">Locrian mode</td>
    <td class="tg-yw4l">C D♭E♭F G♭A♭B♭C</td>
  </tr>
</table>
</center>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
<br>
Clearly there are some kinks left to solve in my clustering algorithm. Most notably, all of the centroids are mysteriously centered in the exact same place, and all of the colors listed are basically just different iterations on a kind of boring murky brown.
</font></div>


<img class="center fit" src="images/kqlvbew4b07q.jpg" >  

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
<br>
I think the problem is clearly that I am not including proximity in my cluster calculations. I should make it so that you could have, for example, one blue cluster on the left, and another on the right. But since I set it up to just sort of cluster by laws of averages, you end up getting these amorphous, murky average-color blobs which are beyond boring.
<br>
<br>
I will get back to this later. For now, I have proven that I can get some interesting data from a photograph, even if it is kind of lame data, so the next step is to prove I can get some music from that data, even if it is kind of lame, I mean even if it is incredible Avant-Garde music. Once I have successfully done both, I can go back and improve a) the quality of my Avant-Garde image analysis algorithm, and b) the quality of my Avant-Garde music-creation algorithm.
<br>
<br>
<center><i>
The Next Chapter Of This Adventure: In Which, After Learning All of both Color Theory and Music Theory, I Entirely & Conclusively Master The Piano Or: In Which, After Producing Unsatisfying Image Analytics Data, I Try To Turn Said Data Into Jazz Music
</i></center>
<br>
<br>
I want to product a 16-bar piano jazz solo. For now, I only plan to play
quarter-notes, so I should be able to create a line of letters like this:
<br>
<br>
<center>1234123412341234123412341234123412341234123412341234123412341234</center>
<br>
<br>
for each centroid, replacing each number with a musical note if/when I want to play said note. I can then print the output of the centroids on separate lines, creating a grid whereby the X axis represents time in quarter notes, the Y axis represents centroids, and any instance of a note is represented by ( N ) where N is the note (eg, A#, B, C-, where # = sharp and - = flat), in lieu of a number. For example, the notes A, B, C and then silence would look like:
<br>
<br>
<center>( A )( B )( C )41234123412341234123412</center>
<br>
<center>34123412341234123412341234123412341234</center>
<br>
<br>
<center><b>Music Creation Pseudo-Code</b></center>
</font></div>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">for</span> each centroid in list of centroids<span style="color: #333333">:</span>
let color ( r, g, b) represent the average color
let number entropy represent the entropy
let number width represent the width
let point ( x, y ) represent the center
create the string which represents an empty <span style="color: #0000DD; font-weight: bold">16</span> bar sequence<span style="color: #333333">:</span>
<span style="color: #0000DD; font-weight: bold">1234123412341234123412341234123412341234123412341234123412341234</span>, and call it bar_string
divide width by the width of the photograph
multiply width by <span style="color: #0000DD; font-weight: bold">16</span> x <span style="color: #0000DD; font-weight: bold">4</span>
let discrete_color represent the primary or secondary color which is
the closest to the average color of the centroid
use this discrete conversion chart to find the related note from
discrete_color
   
 
let that related note be called start_note
<span style="color: #008800; font-weight: bold">for</span> each modal pattern in an array of modal scales<span style="color: #333333">:</span>
calculate the number of incidental notes created by said pattern <span style="color: #008800; font-weight: bold">if</span> you start on start_note
sort the array of resulting calculated patterns in descending order by number of incidentals (this is our measure of entropy)
divide entropy by <span style="color: #0000DD; font-weight: bold">10</span> until it is less than <span style="color: #0000DD; font-weight: bold">100</span>
divide entropy by <span style="color: #0000DD; font-weight: bold">6</span>
cast entropy to an integer and call it int_entopy
let pattern be the modal scale at index int_entropy in the modal scale
list
<span style="color: #008800; font-weight: bold">for</span> each note in pattern<span style="color: #333333">:</span>
place that note in the appropriate spot in the bar_string, replacing the placeholder number there, starting at width number of letters from the start and with start_note
repeat modal scale over and over until the number of notes it fills is equal to the integer cast representation of width, <span style="color: #008800; font-weight: bold">if</span> it is not at least that <span style="color: #333399; font-weight: bold">long</span> already
print the resulting string of characters, and then print a new line
</pre></div>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
<br>
Later, I will find a way to use x, y, width, and entropy more appropriately. I will also tweak my analytics algorithm until it produces more useful (and more colorful!) results. For now, this pseudo-code algorithm represents a good starting point for coding the music creation component.
<br>
<br>
Since this project is modular in nature (yay object oriented coding), I can work on the music creation code until I have something that at least sort of works, and then go back and improve the image analytics code. I would work chronologically, but since this is for a History of Jazz class, rather than a computer science class, I suspect the jazz component of the project may perhaps have more of a bearing on my academic success than the computer science component, and thus merits more immediate attention.
<br>
<br>
As far as a roadmap for this project moving forward is concerned, I expect the following order of events:
<br>
<ol>
<li>Write obj-c code version of pseudocode above</li>
<li>Test obj-c code from step 1 and produce vaguely musical looking output</li>
<li>Translate that musical output into actual musical notation on staff paper</li>
<li>Ask Clara to play the (possibly atrocious, probably totally genius) output on a piano, and record it</li>
<li>Post that recoding on this blog, along with a written evaluation of how interesting, intellectually stimulating, enjoyable, or just plain awful it ends up sounding</li>
<li>Based on that evaluation, go back and tweak the code for music creation</li>
<li>Work on the code for image analytics to add location-based clustering (based on proximity in the photo) and allow for multiple like-colored clusters of different locales</li>
<li>Record Clara playing each note on the piano and put those recordings into an ordered list of files in my Xcode project</li>
<li>Code a function which takes the output from my music creation function (detailed in this post) and uses the recordings from step 8 to actually generate a music file (.wav probably) synthesizing that sound</li>
<li>Code a function which takes the output from my music creation function (detailed in this post) and synthesizes traditional piano staff music representing the jazz solo created by the algorithm</li>
<li>Code functions allowing the user to export created jazz solos to various
popular music notation and music creation apps on the iOS app store in whatever formats those apps employ</li>
</ol>
<br>
I expect I should be able to accomplish steps 1, 2, and to some extent 3 through 8 by the deadline for this assignment. In my view, this is probably more of an exploration of music theory, synesthesia, the creative process, and jazz and I would have accomplished had I simply written a long essay or made a short film or something.
<br>
<br>
Since I plan to ultimately put this app up for free on GitHub as an open source project for others to riff on, as well as to publish it on the iOS App Store, whatever steps I do not complete in time for the grading deadline I will nonetheless complete over the summer. I would rather have fun working on an overly ambitious project than play it safe with a more orthodox venture. Indeed, what could be less jazz-y than playing it safe?
<br>
<br>
<center>PostScript</center>
<br>
<br>
Regarding the Questionable Quality of Music Produced By My Algorithm:
<br>
<br>
<center><i><a href="http://www.brainyquote.com/quotes/authors/m/miles_davis.html">
I’ll play it first and tell you what it is later.</a></i></center>
<center>Miles Davis</center>
<br>
<br>
Regarding The Questionable Artistic Merit of a Coder/Hacker With What One Might Call Attitude Getting a Computer To Make His Jazz Music For Him:
<br>
<br>
<center><a href="http://www.azquotes.com/quote/512320"><i>Anybody can play. The note is only 20 percent. The attitude of the motherfucker who plays it is 80 percent.</i></a></center>
<center>Miles Davis</center>
<br>
<br>
For now, adieu ~
<br>
</font></div>

<center><font face="Hiragino sans" color=#464646 size="7">Jazz Shot, Part IV: A Quick Dip Into The Arts</font></center>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
In class, near the beginning of the term, we discussed the relationship between the visual arts and music. We looked at paintings by artists influenced by jazz, and later in the term we watched a film in which we saw Miles and talking about his paintings.
<br>
<a href="http://www.allaboutjazz.com/celebrating-miles-davis-with-quotes-miles-davis-by-michael-ricci.php">(Amusing tangent - Miles to an interviewer asking why some paintings were displayed on the floor at a gallery opening.)</a>
<br>
<br>
Artists such as Basquiat clearly possess the same sort of radical expressive energy as musicians like Miles. Just today on the radio I heard Paul Simon say that he only made music because of
<br>
<i>"...a decision I made when I was 13, that I wanted to make music. But I could have just as easily chosen something else... And so I think maybe I want to stop myself from writing songs for a bit, and when my creative energy builds up, see where it goes when I constrain myself from what I’m used to."</i>
<br>
<a href="http://www.npr.org/sections/allsongs/2016/05/19/478510693/all-songs-1-a-conversation-with-paul-simon"><footer>Hear the entire interview and a new song by Simon here.</footer></a>
<br>
<br>
Considering the consistent link between visual and musical arts discussed in class, I thought I should try and apply the visual arts to my project. The most obvious application was to try and make a cool app icon. I started with a simple black and white sketch:
</font></div>

<img class="center fit" src="images/cpvnbcfoggcpka.jpg" >  

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
<br>
The concept behind the piece is that it combines music (the musical note) with what should look like a photograph of mountains. And the curvature of the mountain ridge becomes part of the musical notation, just like how in the app a photograph produces a piece of music. But this app icon is hard to see when it’s super small, so I need to try and find a way to increase the contrast. I tried filling in some black:
<br>
</font></div>

<img class="center fit" src="images/61v94fyciwkw.jpg" >  

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
<br>
But that still was not particularly easy to see, nor all that attractive. Ultimately, after a decent amount of work learning to use Pixelmator (I own Photoshop but find it overly feature-dense), I landed on this design:
</font></div>

<img class="center fit" src="images/tpwx1uqjy5xilw.jpg" >

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
<br>
I’m still not totally satisfied with it, but I think it’s definitely a step in the right direction. I can always change it with an app update after I publish, too, so there’s no real rush for now.<br><br>I look forward to further visual exploration of the themes of my app and how to best communicate its usage and creative vision.
</font></div>


<center><font face="Hiragino sans" color=#464646 size="7">Jazz Shot, Part V: The Language of Music</font></center>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
<br>
My friend Clara recently posited that the arts are a set of languages employed to articulate ideas which are “inarticulable” in spoken language. Through music, dance, martial arts (she didn’t specify that one, but I think it’s a safe assumption), etc., people articulate things which go beyond the pale of syntax and words. Specifically, Clara claimed that the arts provide a medium for articulating things which spoken and written language lack the mechanisms to articulate. This is where we differ in opinion. Luckily, I have a blog with one follower (my professor, who is grading this), and so I have the podium to broadcast my beliefs (and Clara does not!).
<br>
<br>
<center><b>The Complexities of Language: Or, A Story of Primordial Soup</b></center>
<br>
<br>
Life on earth likely began around <a href="http://arstechnica.com/science/2015/10/possible-evidence-of-life-on-earth-at-least-4-1-billion-years-ago/">4.1 billion years ago</a>. Life itself is difficult to define, and having taken and aced 9th grade biology I’m sure I at one point could have provided an eloquent definition thereof, but the words now ironically fail me. Regardless, the complexities of life are (realistically) innumerable, beautiful, and a priori the most wondrous aspect of the universe. That the apparently random collisions of what we observe to be particles could result in a being as totally awesome as myself is, let’s face it, proof of the unparalleled and <a href="http://www.oed.com/view/Entry/216010?redirectedFrom=unparallelable#eid">unparallelable</a> beauty of the natural world. But as an aspiring <a href="https://en.wikipedia.org/wiki/Combinatorics">combinatoric mathematician</a>, it is my civic duty to ask:
<br>
<center><i>What is the set-theoretic encoding mechanism of life?</i></center>
<br>
<br>
Luckily, my father is a biologist, and is more than happy to tell me all about it. As Watson and Crick famously discovered when they “borrowed” Rosalind Franklin’s notes, all life on earth (so long as I conveniently define life to ignore most viruses) is programmed by <a href="http://www.britannica.com/science/DNA">DNA</a>.
<br>
<br>
DNA consists of four principle compounds: Cytosine, Guanine, Adenine, and Thymine. In other words, by mixing up four “words” in a beautiful primordial soup and then waiting for about 4.1 billion years, I could cook up this:
</font></div>

<center><iframe width="560" height="315" src="https://www.youtube.com/embed/4r7wHMg5Yjg" frameborder="0" allowfullscreen></iframe></center>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
<br>
It is thus baffling that anyone would ever consider a language limited. What spoken language has less than or equal to four words? <a href="http://www.kli.org">Klingon is a richer language than DNA</a>. Similarly, “on” and “not on”, or 0 and 1, encode all of the information necessary in order to make this MacBook function, and
<br>
<br> 
according to Whitehead and Russel’s famous proof in <a href="http://plato.stanford.edu/entries/principia-mathematica/">Principia Mathematica</a>, one can derive an infinity of sets and super-sets and super- super-sets of numbers, indeed, all of mathematics, from the assumption that at the very least, “nothing” can exist (and one could define a set as being at the very least the set which contains “nothing.”)
<br>
<br>
We now reach the part of the blog where I speak about jazz. With Jazz Shot, I aspire to build an iPhone app which will “translate” photographs (a visual artistic language) into jazzy piano solos (an audible artistic language).
<br>
<br>
<center><i>I use music as a medium to talk to people.</i></center>
<center>Sun Ra</center>
<br>
<br>
By breaking photographs down into their fundamental components, I can describe them mathematically:
<ol>
	<li>Let the set “P” describe a <a href="https://en.wiktionary.org/wiki/quadral">quadral</a> of values (R, G, B, A)</li>
	<li>Let the set “X” describe the width of an image</li>
	<li>Let the set “Y” describe the height of an image</li>
	<li>Let the super-set “L” describe X x Y</li>
	<li>Let the super-super-set “I” describe P x L</li>
</ol>
<br>
<br>
I have a super set which encodes (R, G, B, A) quadral color values to (X, Y) dyad location values. In total, the super-super-set “I” describes an entire photograph.
<br>
<br>
Since pianos are discrete instruments (though as Clara pointed out, old, untuned pianos are not discrete, or at least not consistently so), I can break piano noises up into a mathematical mapping:
<br>
<ol>
	<li>Let the set “N” describe the dyad of values (P, V)</li>
	<li>Let the set “T” describe all of the real numbers</li>
	<li>Let the set “M” describe a mapping of N x T</li>
</ol>
<br>
P = pitch (easily quantified with the oscillatory frequency of sound), and V = volume (easily quantified with <a href="http://hyperphysics.phy-astr.gsu.edu/hbase/sound/intens.html#c1">decibels</a>). By mapping N to T, I get all possible notes at all possible volumes played at all possible moments in time.
<br>
<br>
<center><i>I’m a musician, but another kind of musician.</i></center>
<center>Sun Ra</center>
<br>
<br>
At this point, since I have set-theoretic definitions for both all of photographs and all of piano music, mapping from one to the other can’t be that hard. But mapping from one to the other in a way which articulates a sentiment or idea anything whatsoever like the sentiment or idea present in the original medium is nigh on impossible. In other words, the languages of images and music are clearly infinity powerful: they can be described mathematically, and they are more complex and powerful than the languages with which life, math, and/or computers are made to function. The limiting factor is my creative capacity to invent a translation which actually preserves some of the original meaning.
<br>
<br>
<center><i>
Music is a language, you see, a universal language.</i></center>
<center>Sun Ra</center>
<br>
<br>
If 4 “words” can encode all of life, a box of nothing can encode all of math, and a light-switch can encode all of computation, then the fundamental limitations of the use of language by humans are clearly the humans involved, not the languages themselves. <b>Sun Ra is onto something</b>: “space is the place,” and its fundamental lesson is that even pure randomness can articulate more beautiful concepts with exponentially fewer words than we can.
<br>
<br>
Writing the code for Jazz Shot is difficult, but the real challenge is writing it in a way such that it communicates something of the original image in the final music. That difficulty exists because I am not smart enough to immediately intuit the perfect algorithm - I doubt anyone is. But my incapacity to intuit the fundamental truths of quantum mechanics and color theory and the human condition in no way negates the existence of said truths. And piano music - encoded as it is in a discrete set of easily mathematically described and mapped notes - possesses more than enough complexity to describe even the most indescribable of ideas.
<br>
<br>
The task of accurately translating photographs to music is provably possible, even if I don’t end up doing all that good of a job at it. It’s an <a href="http://mathworld.wolfram.com/NP-Problem.html">NP- problem</a> in a world of P solutions, and my app is more an observational experiment than a mathematical procedure. The experimental and observational nature of the endeavor is, to me, what makes this project fundamentally <i>jazzy</i>; even failure would produce interesting and actionable knowledge. And maybe I’ll succeed!
<br>
<br>
<center><i>The light of the future casts the shadows of tomorrow.</i></center>
<center>Sun Ra</center>
<br>
</font></div>

<center><font face="Hiragino sans" color=#464646 size="7">Jazz Shot, Part VI: A Link And Little Else</font></center>

<div id="tutorial">
<font face="Hiragino sans" color=#323232 size="4">
<br>
As I work on moving into my new house in Flagstaff, Arizona, I am not working anywhere near enough on my side project (Jazz Shot) or my other side project (Sam’s Game) or any of my other other side projects (Cert Jerk, Chirp Alert, Molusk, Bluster, etc.). On the bright (is it bright?) side, Google is working on similar projects, and probably doing a better job at it. <a href="http://www.theverge.com/2016/6/1/11829678/google-magenta-melody-art-generative-artificial-intelligence">Read more here about Google’s artificial-intelligence-generated piano solo.</a> <a href="http://arstechnica.com/the-multiverse/2016/06/an-ai-wrote-this-movie-and-its-strangely-moving/">Read more here about an artificial-intelligence-written film.</a>
<br><br>
Hasta I get anywhere near done unpacking, Ciao.
<br><br>
NOTE: At least for now, this is an abandoned project.  If you find it interesting and would like to take up the reigns, shoot me a DM or an email and I'd be happy to chat on the progress I made, my thoughts on how best to move foreword, etc.  Any content whatsoever in this blog post is available under MIT license with attribution.  If you'd like to make money and not make your code similarly MIT-licensed, email me, and we can work something reasonable out.  I do believe it would be entirely possible to make money off of an app like Jazz Shot.  I just have other ideas and work which interest me more right now.
</font></div>

<script src="http://code.jquery.com/jquery-latest.js"></script>
<script type="text/javascript" language="JavaScript">
  function set_body_height() { // set body height = window height
    $('body').height($(window).height());
  }
  $(document).ready(function() {
    $(window).bind('resize', set_body_height);
    set_body_height();
  });
</script>

</body>

</html>